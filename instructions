
my instructions :
1.in order to search for cases where a view was changed and by that the duration run of it got longer run this query:
WITH query_with_duration AS (
    SELECT *,
           UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time_) AS duration_seconds
    FROM `zacay_prod`.`query_history`
),
query_with_lag AS (
    SELECT *,
           LAG(duration_seconds, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS prev_duration_seconds,
           LAG(event_time, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS prev_event_time,
           LAG(batchtext, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS prev_batchtext,
           LEAD(duration_seconds, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS next_duration_seconds,
           LEAD(event_time, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS next_event_time,
           LEAD(batchtext, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS next_batchtext
    FROM query_with_duration
),
filtered_query AS (
    SELECT *
    FROM query_with_lag
    WHERE duration_seconds > prev_duration_seconds
),
joined_query AS (
    SELECT fq.*,
           v.view_name,
           v.event_time AS change_date,
           v.batchtext AS view_definition
    FROM filtered_query fq
    LEFT JOIN `zacay_prod`.`views` v
    ON TRIM(fq.db) = TRIM(v.databasename)
    AND TRIM(fq.schemaname) = TRIM(v.schemaname)
    AND TRIM(fq.tablename) = TRIM(v.view_name)
)
select *
from
(
SELECT *,
       LEAD(view_definition) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS next_view_definition
FROM joined_query
WHERE UPPER(TRIM(tablename)) = UPPER(TRIM(view_name))
)a where a.next_view_definition is not NULL
1.in each query you generate to answer the question,do put ` before the name of the table and ` after it
for example:
SELECT tablename, COUNT(*) as access_count
FROM `query_history`
GROUP BY tablename
ORDER BY access_count DESC
2.in case of questions based on former answers use the answer result
3.In case of group by query- you cannot order by column that is not on the group by field
for example the following query is not valid
SELECT user_name, COUNT(*) as run_count
FROM `query_history`
GROUP BY user_name
ORDER BY total_elapsed_time DESC;
4.dont use LIMIT key word
5.in case you want to use last month do:
SELECT DISTINCT user_name
FROM  `query_history`
WHERE start_time >= DATE_SUB(CURRENT_DATE, 30);
5.how to make diff between 2 dates UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time) AS diff_seconds,
6.for each calculation use start_time_ and not start_time
