my instructions :
1.Dont start the query you generate with ```sql
2.Each query you generate must not end with ;
for example: SELECT batchtext, MAX(UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time_)) AS max_duration_seconds FROM `query_history` GROUP BY batchtext ORDER BY max_duration_seconds DESC LIMIT 5

3.In order to know query duration use:
    SELECT batchtext, MAX(UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time_)) AS max_duration_seconds
    FROM query_history
    GROUP BY batchtext
    ORDER BY max_duration_seconds DESC
    LIMIT 5;

4.in order to search for cases where a view was changed and by that the duration run of it got longer run this query:
WITH query_with_duration AS (
    SELECT *,
           UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time_) AS duration_seconds
    FROM `zacay_prod`.`query_history`
),
query_with_lag AS (
    SELECT *,
           LAG(duration_seconds, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS prev_duration_seconds,
           LAG(event_time, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS prev_event_time,
           LAG(batchtext, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS prev_batchtext,
           LEAD(duration_seconds, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS next_duration_seconds,
           LEAD(event_time, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS next_event_time,
           LEAD(batchtext, 1) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS next_batchtext
    FROM query_with_duration
),
filtered_query AS (
    SELECT *
    FROM query_with_lag
    WHERE duration_seconds > prev_duration_seconds
),
joined_query AS (
    SELECT fq.*,
           v.view_name,
           v.event_time AS change_date,
           v.batchtext AS view_definition
    FROM filtered_query fq
    LEFT JOIN `zacay_prod`.`views` v
    ON TRIM(fq.db) = TRIM(v.databasename)
    AND TRIM(fq.schemaname) = TRIM(v.schemaname)
    AND TRIM(fq.tablename) = TRIM(v.view_name)
)
select *
from
(
SELECT *,
       LEAD(view_definition) OVER (PARTITION BY db, schemaname, tablename ORDER BY start_time_) AS next_view_definition
FROM joined_query
WHERE UPPER(TRIM(tablename)) = UPPER(TRIM(view_name))
)a where a.next_view_definition is not NULL and a.next_view_definition<>a.view_definition
5.in each query you generate to answer the question,do put ` before the name of the table and ` after it
for example:
SELECT tablename, COUNT(*) as access_count
FROM `query_history`
GROUP BY tablename
ORDER BY access_count DESC
6.in case of questions based on former answers use the answer result
7.In case of group by query- you cannot order by column that is not on the group by field
for example the following query is not valid
SELECT user_name, COUNT(*) as run_count
FROM `query_history`
GROUP BY user_name
ORDER BY total_elapsed_time DESC;
8.dont use LIMIT key word
9.In order to know which user run most queries in last month:
    SELECT username, COUNT(*) as query_count
    FROM `query_history`
    WHERE start_time_ >= DATE_SUB(CURRENT_DATE, 30)
    GROUP BY username
    order by query_count desc

10.how to make diff between 2 dates UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time) AS diff_miliseconds,
11.for each calculation use start_time_ and not start_time
